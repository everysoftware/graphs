"""
Простые представления графа: список ребер, матрица смежности и список смежности
"""

from src.models.data import GraphData, EdgeData
from src.models.types import Weight, NodeKey

"""
Список ребер.

Список ребер - это список кортежей, где каждый кортеж - это ребро графа. Каждое ребро представляется в виде кортежа
из трех элементов: (начальная вершина, конечная вершина, вес ребра). 

Пример:
[(1, 2, 5), (2, 3, 7), (3, 1, 2)]

Преимущества:
- простота реализации
- ориентированный и не ориентированный графы

Недостатки:
- только целые числа
- сдвиг массива при добавлении нового ребра
- поиск родителей за O(n)

Подробнее:
- только целые числа: актуально для C++, где массивы - это непрерывная область памяти элементов одного типа. 
Вес ребра - целое число, значит и все остальные данные массива должны быть целыми числами (int[n][3]).
- сдвиг массива при добавлении нового ребра: допустим, есть массив ребер [(2, 1, 7)] и мы хотим добавить новое ребро
(1, 2, 5). Для быстрого поиска детей ребра должны быть отсортированы. Поэтому мы должны сдвинуть массив, а потом уже 
добавлять: [(1, 2, 5), (2, 1, 7)]. Получаем сложность добавления: O(n), где n - это число ребёр графа.
- поиск родителей за O(n): если мы хотим найти всех родителей вершины 2, то нам придется пройтись по всем ребрам и
проверить конечную точку ребра. Получаем сложность O(n), где n - это число ребёр графа.
"""


def edge_list(graph: GraphData) -> list[EdgeData]:
    """
    Возвращает список ребер графа.
    """
    return graph.edges


"""
Матрица смежности.

Матрица смежности - это двумерный массив, где каждый элемент - это вес ребра. Если вес ребра равен 0, то ребра между
вершинами нет. Если вес ребра больше 0, то ребро есть. 

Пример:
[
    [0, 5, 0],
    [0, 0, 7],
    [2, 0, 0]
]

Преимущества:
- визуализация структуры связей
- удобство хранения и обработки данных, особенно, для неразреженных графов
- быстрый поиск рёбер за O(1)

Недостатки:
- перерасход памяти для разреженных графов
- только целые числа от 0
- добавление / удаление вершин за O(n^2)

Подробнее:
- перерасход памяти для разреженных графов: если в графе 100 вершин и 10 ребер, то матрица смежности будет иметь размер
100x100, но в ней будет только 10 ненулевых элементов. Такие графы называются разреженными. В таких графах матрица
смежности будет занимать много памяти, хотя в ней мало данных.
- только целые числа от 0: матрица смежности способна хранить только целочисленные вершины от 0. 
Это ограничение связано с тем, что матрица смежности - это двумерный массив, 
в котором начальная и конечная вершины ребра - это индексы массива. А индексы массива - это целые числа от 0.
- добавление / удаление вершин за O(n^2): если мы хотим добавить вершину 8, то нам придется создать новый массив
размером 9x9 и скопировать в него все данные из старого массива. Получаем сложность: O(n^2), 
где n - это число вершин графа.
"""

AdjacencyMatrix = list[list[Weight]]


def adjacency_matrix(graph: GraphData) -> AdjacencyMatrix:
    """
    Возвращает матрицу смежности графа.
    """
    matrix = [[0 for _ in range(graph.size)] for _ in range(graph.size)]

    for edge in graph.edges:
        matrix[edge[0] - 1][edge[1] - 1] = edge[2]

    return matrix


"""
Список смежности.

Список смежности - это один из способов представления графа в виде коллекции списков вершин. 
Каждой вершине графа соответствует список, состоящий из «соседей» этой вершины.

Пример:
{
    'A': [('B', 1)],
    'B': [('C', 2)],
    'C': [('A', 3), ('B', 4)]
}

Преимущества:
- компактность: список смежности обычно занимает меньше памяти, чем другие представления графа, 
особенно для разреженных графов.
- эффективность: список смежности позволяет быстро итерировать по всем соседям конкретной вершины.
- простота добавления и удаления вершин и ребер: в список смежности легко добавлять новые вершины и ребра.
- определение степени вершины: список смежности позволяет легко определить степень каждой вершины графа, 
которая определяет количество ребер, связанных с данной вершиной.

Недостатки:
Однако, стоит отметить, что списки смежности могут быть менее эффективными для проверки наличия ребра
между двумя вершинами, поскольку это может потребовать обхода всего списка соседей. Это опять же 
про поиск родителей за O(n), где n - число рёбер.
"""

AdjacencyList = dict[NodeKey, list[tuple[NodeKey, Weight]]]


def adjacency_list(graph: GraphData) -> AdjacencyList:
    """
    Возвращает список смежности графа.
    """
    lst = {}

    for edge in graph.edges:
        if edge[0] not in lst:
            lst[edge[0]] = []
        lst[edge[0]].append((edge[1], edge[2]))

    return lst
